= Automatyczne zarządzanie pamięcią w JVM
:backend: revealjs
:highlighter: pygments
:stem: asciimath
:source-highlighter: pygments
:pygments-css: style
:revealjs_theme: serif
:revealjs_history: true

== Automatyczne zarządzenie pamięcią

* Automatyczne zarządzanie pamięcią (odśmiecanie) to nie nowy problem
* John McCarthy w 1959 proponuje automatyczne zarządzanie pamięcią na potrzeby implementacji języka Lisp
* Dostępne techniki 
** Reference counting
** Tracing garbage collectors

=== Zliczanie referencji

Zliczanie referencji to forma automatycznego zarządzania pamięcią w której każdy obiekt ma licznik ilości odniesień do niego. Śmieci są identyfikowane poprzez posiadanie liczby odniesienia równej zero. Licznik odwołań jest zwiększany, gdy odniesienie do obiektu jest tworzone i zmniejszany, gdy odwołanie jest usuwane. Pamięć zajmowana przez obiekt jest zwalniana, gdy liczba osiągnie zero.

=== Wady i zalety

* Pamięć jest zwalniana natychmiast gdy wartość licznika osiągnie zero
* Wymaga dodatkowych technik aby wykryć cykle odwołań
* W środowisku wieloprocesorowym dostęp do licznika referencji musi być synchronizowany (atomic)

=== Śledzenie referencji

* Tracing garbage collector najpierw określa które obiekty są dostępne (osiągalne), a następnie usuwa te które są nieosiągalne
* Podstawowym mechanizmem w algorytmach GC typu „tracing” jest tzw. „reachability analisys”
* Umożliwia ona określenie czy dany obiekt jest osiągalny (czasami określany jako „live object”)
* Obiekt jest osiągalny/”żywy” gdy jest co najmniej jedno odwołanie do tego obiektu, z innego obiektu który jest osiągalny, bezpośrednio lub też poprzez innego obiekty, które są osiągalne (transistive closure)

=== Wady i zalety 

* Analiza „reachability of objects” rozpoczyna się od tzw. „garbage collection roots”,
** Obiekty znajdując się na stosie wątku, „żywego wątku”
** Klasy załadowane przez systemowy „class loader”
** Zmienne lokalne i globalne JNI (Java Native Interface)
** Obiekty wykorzystywane jako monitory podczas synchronizacji

=== Pokoleniowa analiza

    It has been empirically observed that in many programs,
    the most recently created objectsare also those most
    likely to become unreachable quickly
    (known as infant mortality or the generational hypothesis)
    - Wikipedia

== Założnie teorii pokoleniowej

* Pokoleniowy odśmiecanie pamięci bazuje na dwóch założeniach,
** Większość nowych obiektów szybko staje się nieosiągalnych
** Ilość odwołań z starych obiektów do nowych obiektów jest niewielka

== Automatyczne zarządzanie pamięcią a JVM

* Oracle JVM/OpenJDK
** Serial
** Parallel
** Concurrent mark sweep
** G1 - Garbage First

=== Poza Oracle/OpenJDK

* Shenandoah: http://openjdk.java.net/jeps/189[An Ultra-Low-Pause-Time Garbage Collector]
* Oracle JRockit Real Time 
* IBM Websphere Real Time
* Azul Zing (pauseless)

=== Alokacja pamięci

* W przypadku pokoleniowego („generational” GC) , alokacja nowych obiektów odbywa się tylko w przestrzeni „Eden”
* Dostępne techniki to:
** „bump-the-pointer”
** TLAB (Thread Local Allocation Buffer)

=== TLAB


[shaape]
----
      Thread1    Thread2    Thread3    Thread4
    +---+----+ +--------+ +--------+ +--------+ 
    |   |    | |        | |        | |        |
    |   |    | |        | |        | |        |
    +---+----+ +--------+ +--------+ +--------+
options:
 - ".*": {fill: [white, no-shadow], frame: [blue, dashed]}
----

=== Organizacja pamięci w JVM

[shaape]
----
+---------------------------+-----------------+-----------------+
|            New            |    Survivor0    |    Survivor1    |
+---------------------------+--------------+--------------------+
|                        Tenured/Old                            |
+---------------------------------------------------------------+

+---------------------------------------------------------------+
|                         Metaspace                             |
+---------------------------------------------------------------+
----

=== Śledzenie

[graphviz]
----
digraph {
	A->B
	A->C
	A->D

	B->E
	C->E

	F->G
	G->H
	
}
----

=== Reachability analisys

* An object is alive if it is referenced by a live object.
* An object is alive if a static reference to it exists (part of the root set).
* An object is alive if a stack reference to it exists (part of the root set).

=== Faza "mark"

* "reachability analisys" rozpoczyna się od obiektów znanych jako "GC roots"
* każdy z tych obiektów jest odwiedzany, i oznaczany jako "alive"
* pozostałe obiekty które nie zostały oznaczone jako "alive" są usuwane
* faza ta wymaga zatrzymania wszystkich wątków aplikacji, tzw. "stop the world"
* faza "mark" nie jestem jedyną przyczyną pauz w aplikacjach działających pod kontrolą JVM (ale o tym później)

=== Garbage Collection roots

* zmienne lokalne
* wątki
* pola statyczne
* JNI
* pozostałe inne

=== Typy algorytmów 

* mark+copy
* mark+sweep+copy

=== Znakowanie kart i bariery

Warto zauważyć że podczas fazy "mark" analizowane są tylko obiekty w przestrzeni Young/New.
W przeciwnym wypadku cała pokoleniowa hipoteza nie miałaby sensu wydajnościowego (analiza
całej pamięci, zamiast tylko obszaru w którm zakładamy, że mamy krótko żyjące obiekty).

Co z obiektami z przestrzeni Young/New, do których istnieje referencja z obiektów znajdujących się w
przestrzeni Old/Tenured?

=== Znakowanie kart i bariery

W tym celu zostały wprowadzone dwa mechanizmy:

* znakowanie kart, "card marking"
* bariery (nie mylić ich z barierami odpowiedzialnymi za kolejność wykonywania instrukcji przez CPU, tzw. "ordering barrier", ale o tym później)

=== Znakowanie kart

* obszar pamięci JVM, jest podzialone na małe fragmenty tzw. "cards", o rozmiarze mniejszym niż pojedyncza strona pamięci, domyślnie 512 bajtów
* JVM utrzymuję mapę która przechowuje wartość flagi ("dirty") dla każdej karty
* kiedy pole obiektu jest modyfikowane, ustawiana jest flaga "dirty"
* jak to się dzieje?

=== Bariery

    A barrier is a block on reading from or writing to certain memory
    locations by certain threads or processes.

    Barriers can be implemented in either software or hardware.
    Software barriers involve additional instructions around
    load or store operations, which would typically be added
    by a cooperative compiler. Hardware barriers don’t require
    compiler support, and may be implemented on common
    operating systems by using memory protection.

=== Małe, duże i pełne pauzy

* minor
* major
* full

=== Dla ciekawych

* http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html[The JVM Write Barrier - Card Marking]
* http://www.ibm.com/developerworks/library/j-jtp11253/[Java theory and practice: Garbage collection in the HotSpot JVM]
* http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html[Understanding GC pauses in JVM, HotSpot's minor GC.]
* http://www.memorymanagement.org[Memory Management Reference]

=== Warunkowe znakowanie kart

* 
* '-XX:UseCondCardMark'

=== Niepraktyczne informacje zarządzaniu pamięcią 

== ParallelGC

* Od Java 5 domyślny “garbage collector” (z nadejściem JDK9, planowane zastąpienie go G1) 
* Wykorzystuje wiele wątków do odśmiecania pamięci, działa tylko w obszarze Young
* jest to odśmiecacz typu mark+copy, obiekty są kopiowane do przestrzeni Survivor
* JVM posiada dwie przestrzenie Survivor (Survivor0 + Survivor1), znane także jako "To" i "From"
* przestrzenie Survivor mają ten sam rozmiar

== Mechanika ParallelGC

* “GC roots” zostają rozdzielone między dostępne wątki, dzięki temu faza “mark” jest krótsza (pamiętajmy jednak o "stop the world")
* Każdy “żywy” obiekt jest natychmiast kopiowany do przestrzeni “To”, lub do przestrzeni “Old” 
** jeśli przetrwał odpowiednią ilość kolekcji w przestrzeni Young
** lub gdy w „To” nie ma już miejsca dla obiektu (major GC)

== Mechanika ParallelGC

* Przestrzeń “To” staje się przestrzenią “From” i “From”->”To”
* Czyli po każdym przebiegu tego odśmiecacza przestrzeń „To” jest pusta
* Ponieważ „mark and copy” odbywa się wielowątkowo, każdy z wątków GC dostaje swój wycinek “To”
* Bo przecież alokacja nowych obiektów, odbywa się tylko w przestrzeni “Eden”, więc nie będzie nam przeszkadzała lekko defragmentowana przestrzeń “To”

=== Kilka pokręteł

* -XX:NewRatio=2
* -XX:SurvivorRatio=10
* -XX:TargetSurvivorRatio=90
* -XX:MaxTenuringThreshold=30

== ParallelOldGC 

* Jednak nie dajmy się zwieźć pozorom, -XX:+UseParallelGC i -XX:+UseParallelOldGC to dwie odmienne implementacje, ParallelOldGC ma do czynienia z o wiele większą przestrzenią generacji “Old”
* Domyślnie na maszynach z N procesorów, wykorzystywanych jest N wątków
* Jednak ilość wątków może być kontrolowana przez parametr -XX:ParallelGCThread=N
* jest to algorytm typu mark+sweep+copy

=== Mechanika ParallelOldGC

* O wiele bardziej złożony algorytm, gdyż przestrzeń “Old” jest znacząco większa od przestrzeni „Young” a obiekty, które się tam znajdują wykazują się większym czasem życia
* ParallelOldGC odbywa się w trzech fazach:
** parallel marking
** summary step
** sweeping step

=== Mechanika ParallelOldGC

* Przestrzeń “Old” zostaje podzielona na regiony
* “GC roots” podzielone pomiędzy w wątki GC
* Za każdym razem gdy obiekt zostanie oznaczony jako “live” (“reacheable”), region w którym się znajdował, zostaje zaktualizowany o ilość “żywych bajtów”
* Dzięki temu na koniec tej fazy wiadome jest ile w danym regionie znajduje się „żywych” danych

== 

* Dla każdego regionu, jest wyznacza wartość “density” (stosunek ilość żywych bajtów do całkowitej ilości bajtów) 
* W tym kroku wiemy także, że podczas poprzedniej kolekcji:
* ** obiekty były kompaktowane do lewej
** nowe obiekty które od tego czasu zostały przeniesione do “Old” znajdują się po prawej stronie
** Więc im obiekt bardziej na lewo tym starszy, tym mniejsza szansa, że będzie usuwany z pamięci

== 

* Powyższe informacje pozwalają na pewna optymalizacje:
* ** zaczynając od lewej, szukany jest region o gęstości (“density”), z którego najwięcej zyskamy jeśli go posprzątamy,
** wszystkie region na lewo nie sprzątane, i nazywane są “dense prefix”
* Dodatkowo podczas tej fazy już wiadomo obiekty z którego regiony zostaną przeniesione do danego regionu (z reguły te na prawo wypełniają te na lewo)

== 

* Regiony które mogą być sprzątane jednocześnie są dzielone miedzy watki,
* ** region które nie zapełniają innych regionów (patrz poprzedni krok)
** lub region które są puste,
* Wątki najpierw usuwają „unreachable objects”
* A potem przesuwają obiekty (compact)
* Dzięki optymalizacji (nie skanujemy całego regionu „Old”), możemy odzyskać dużo pamięci, mniejszym kosztem, ponieważ na lewo są stare obiekty 

== 

* A potem przesuwają obiekty (compact)
* Dzięki optymalizacji (nie skanujemy całego regionu „Old”), możemy odzyskać dużo pamięci, mniejszym kosztem, ponieważ na lewo są stare obiekty

== 

* A co z tymi obiektami, które znajdują się regionie „Old” i posiadają referencji do obiektów w generacji „Young”?
* Zastosowany jest mechanizmy znane jako "card table" i write barrier

== ConcMarkSweepGC 

* Poprzednie kolektory, są szybkie, jednak muszą zatrzymać działanie aplikacji (high throughput/high pause time)
* Kosztem mniejszej wydajności CMS
* Cztery kroki
** initial mark
** concurrent mark
** remarking
** concurrent sweep

== 

* Zatrzymuje watki aplikacji na krótka chwile, by w wykorzystujac jeden watek, zaznaczyc tylko obiekty które sa bezposrednio dostepne z “GC roots”

== 

* Podczas gdy aplikacja działa dalej, osobny wątek GC kontynuuje zaznaczanie obiektów,

== 

* Ponieważ sytuacja w między czasie może się zmienić CMS, znowu na chwile zatrzymuje aplikacje, by sprawdzić te obiekty które się z międzyczasie zmieniły

== 

* Następuje sprzątanie, w wielu watkach, bez kompaktowania
* Dlatego też alokacja pamięci odbywa się na trochę innych zasadach

== 

174.445: [GC 174.446: [ParNew: 66408K->66408K(66416K), 0.0000618 secs]174.446: [CMS (concurrent mode failure): 161928K->162118K(175104K), 4.0975124 secs] 228336K->162118K(241520K) 
== 

* W przypadku pojawienia się tego komunikatu, CMS zostaje na czas tego uruchomienia „Full GC” zastąpione SerialGC
* Concurrent Mode Failure jest wynikiem defragmentacji generacji „Old” i niemożliwością zaalokowania odpowiedniego ciągłego obszaru pamięci. 

== 


== 

* Analiza dostępności obiektów - „reachability analisys”
* Kopiowanie obiektów pomiędzy przestrzeniami compacting vs non-compacting vs copying
* Aktualizacja referencji do obiektów które zostały przeniesione
* Kompaktowanie pamięci

== 

* G1 znany także jako „garbage first”, to nowy algorytm, który w wersji eksperymentalnej pojawił się już w Java 6, w pełni wspierany od wersji 7u4
* -XX:+UseG1GC
* Jest kolejna próba zminimalizowania pauz w działaniu aplikacji, przy jednoczesnym kompaktowaniu pamięci (przestrzeni „Old”)

== 

* Podobnie jak w przypadku poprzednich modeli pamięć jest podzielona na obszary, w których przechowywane są obiekty w rożnym wieku
* W przeciwieństwie jednak do poprzedników, tych obszarów tworzonych przez G1 mamy do dyspozycji około 2000, każdy z tych obszarów ma taki sam rozmiar, -XX:G1HeapRegionSize=n

== 

* Implementacja G1 utrzymuje listę regionów, które są wolne, i miarę zapotrzebowania przypisuje te regiony do generacji „Young” (Eden/Survivor) lub „Tenured” („Old”)
* W tej implementacji przestrzenie nie są ciągłym obszarem pamięci
* Dzięki temu rozmiar Eden/Survivor/Old może być dostosowywany do zapotrzebowania aplikacji
* Podobnie jak w poprzednich implementacjach, obiekty są promowane( ewakuowane w słowniku GC) do obszarów, które zawierają coraz starsze obiekty

== 

* Alokacja podobnie jak w poprzednich algorytmach, odbywa się głównie w przestrzeni „Eden”, 
* Chyba, że obiekt jest większy niż połowa rozmiary regiony, wtedy takie obiekty są alokowane w specjalnych przestrzeniach zwanych „humongous”
* Kiedy pojemność „Eden” zostanie osiągnięta, rozpoczyna się faza „young garbage collection”, nazywana także „evacuation pause”
* Jest to faza „stop-the-world”, podczas której wykorzystwane jest wiele wątków, i obiekty kopiowane są do „to-space”, lub też w zależności od wieku obiektu (tenured threshold) do przestrzeni „old”

== 

* "Serial" to odśmiecacz typu „stop-the-world”, kopiujący kolekcjoner który wykorzystuje tylko jeden wątek
* "ParNew" to odśmiecacz typu „stop-the-world”, kopiujący kolekcjoner, który wykorzystuje wiele wątków. Różni się od "Parallel Scavenge" pewnymi usprawnieniami które umożliwiają wykorzystanie go w parze z CMS

== 

* "Parallel Scavenge" to odśmiecacz typu „stop-the-world”, kopujący algorytm który wykorzystuje wiele wątków
* "Serial Old" to odśmiecacz typu „stop-the-world”, „mark-sweep-compact” który wykorzystuje pojedynczy wątek
* "ConcurrentMarkSweep" (CMS) to prawie „współbieżny” odśmiecacz, zapewniający krótkie pauzy .
* "Parallel Old" to implementcja ParallelGC na potrzeby generacji „Old”

== 

* UseSerialGC to "Serial" + "Serial Old"
* UseParNewGC to "ParNew" + "Serial Old"
* UseConcMarkSweepGC to"ParNew" + "CMS" + "Serial Old". "CMS" jest wykorzystywany przez większość czasu podczas kolekcji generacji „tenured”. "Serial Old" jest wykorzystywany w sytuacjach wystąpienia „concurrent mode failure„.
* UseParallelGC to "Parallel Scavenge" + "Serial Old"
* UseParallelOldGC to "Parallel Scavenge" + "Parallel Old" 

== 

* PermGen to wydzielony obszar z generacji „tenured” w którym JVM przechowuje:
** „bytecode” metod czyli „method area”
** „constant pool”
** „interned strings” (jest to nieprawdą dla JDK7)
** struktury wewnętrznie wykorzystywane przez JVM
* Generacja „permament” (PermGen) jest odśmiecana za każdym razem gdy odśmiecana jest generacja „tenured”

== 

* Jeśli twoja aplikacja lub biblioteka intensywnie używa,
** java.lang.reflect.Proxy
** net.sf.cglib.Enhancer
** javassist.util.proxy.ProxyFactory
** Apache commons proxy
** AspectJ z „runtime weaving” (SpringFramework się też liczy)
* To wiedz, że PermGen wypełni się szybko
* Dlaczego?

== 

* Poniższe metryki opisują efektywność odśmiecania pamięci
** Przepustowość (throughput)Procent czasu nie spędzanego przez aplikacje na odśmiecaniu, 100% oznacza brak odśmiecania, przyjęło się przyjmować 95-98% jak poprawną wartość
** Narzut na odśmiecanie (GC overhead)odwrotność przepustowości, czyli procent czasu spędzanego przez aplikację na odśmiecanie

== 

** Czas pauzy (pause time)Czas podczas którego działanie aplikacji jest wstrzymane na potrzeby odśmiecania
** Częstotliwość odśmiecania(frequency of collection)jak często w czasie życia aplikacji następuje odśmiecanie

== 

** Narzut pamięci (footprint)Rozmiar pamięci wykorzystywanej przez maszynę JVM
** Promptnessczas pomiędzy momentem kiedy obiekt stał się „unreachable” a momentem kiedy pamięć przez niego zajmowana została zwolniona

== 

* Proste jednak kompletnie niepraktyczne narzędzie to:jmap -heap <vmid>

* Jest to jednak najszybszy sposób żeby sprawdzić z jakimi parametrami odśmiecania aktualnie działa uruchomiona maszyna wirtualna

== 


== 

* Poprzez parametry przekazywane do maszyny wirtualnej
* -XX:+PrintGC
** Major or minor collection
** Rozmiar sterty (generacji) przed odśmiecaniem
** Rozmiar sterty (generacji) po odśmiecaniu
** Całkowity rozmiar sterty (generacji)
** Czas odśmiecania

== 


== 

* -XX:+PrintGCDetails i -XX:+PrintGCTimeStamps
** Bardziej szczegółowe informacje, szczególnie dla algorytmu ConcurrentMarkSweep, gdzie wypisywane są czasy i rozmiar pamięci dla poszczególnych faz

== 


== 

* -XX:+PrintTenuringDistribution
** wyświetla informacje o rozmiarach poszczególnych kategorii wiekowych, ilości odśmiecań, które obiekty przetrwały zanim zostały wypromowane do generacji „Tenured”

== 


== 

* -Xloggc:<filename>zapisuje logi z odśmiecania w wskazanym pliku
* -XX:+UseGCLogFileRotationwłącza rotację plików z logami GC
* -XX:NumberOfGClogFiles=1maksymalna ilość plików z logami GC
* -XX:GCLogFileSize=8Kmaksymalny rozmiar pliku z logami

== 

* Kolejnym narzędziem dostępnym z linii poleceń jest jstat, rozpowszechniany razem z Java SDKjstat -option [-t] [-hlines] vmid [interval [count]]
* Gdzie vmid, jest identyfikatorem procesu JVM,
* jstat umożliwia podpięcie się do procesu JVM i zbieranie różnego typu statystyk, 

== 

* -option to typ statystki którą ma wyświetlać jstat
** class
** compiler
** gc
** gccapacity
** gccause
** gcnew
** gcnewcapacity
** gcoldoldcapacity
** gcpermcapacity
** gcutil

== 

* Warto zapoznać się z powyższymi narzędziami jak i formatami w jakich udostępniane są statystki odśmiecania, jednak na co dzień warto korzystać z wizualnych 
* VisualVM
** Wtyczka VisualGC, wymaga dodatkowej instalacji, pokazuje bieżące zachowanie GC
* GCviewer
** 
		link:https://github.com/chewiebug/GCViewer[https://github.com/chewiebug/GCViewer]
	, szwajcarski scyzoryk w temacie GC
* Jhiccup
** 
		link:http://www.azulsystems.com/jHiccup[http://www.azulsystems.com/jHiccup]
	, czyli mamy czkawkę, czy nie?

== 

* Spośród wielu metryk opisujących zachowanie GC, musisz wybrać jedną, pod którą będziesz starał się zoptymalizować parametry odśmiecania
* Najczęściej będą to:
** Rozmiar sterty
** Przepustowość
** Czas pauzy

== 

* Przedwczesna optymalizacja GCnie rób tego jeśli naprawdę nie musisz
* Brak wiary w ergonomię GCbyć może -XX:MaxGCPauseMillis=<nnn> i -XX:GCTimeRatio=<nnn> to jedyne parametry które powinieneś znać
* Wiara że optymalizacja GC przykryje złe nawyki w pisaniu kodu czy też brak pragmatyzmu w architekturze systemu

== 

* Brak systemowego/całościowego podejścia do testowania wydajności
* stackoverflow.com i google.com to nie są miejsca gdzie znajdziesz parametry swojego JVM
* Brak zrozumienia jak działają poszczególne algorytmy odśmiecania i interakcji pomiędzy JVM i systemem operacyjnym

== 

* Spośród wielu metryk opisujących zachowanie GC, musisz wybrać jedną, pod którą będziesz starał się zoptymalizować parametry odśmiecania
* Najczęściej będą to:
** Rozmiar sterty
** Przepustowość
** Czas pauzy

== 

* Różne wymagania alokacji i odśmiecanie dla różnych architektur
** Przetwarzanie wsadowe
** Aplikacje stanowe i bezstanowe
