= Automatyczne zarządzanie pamięcią w JVM
:backend: revealjs

== 

* Automatyczne zarządzanie pamięcią (odśmiecanie) to nie nowy problem
* John McCarthy w 1959 proponuje automatyczne zarządzanie pamięcią na potrzeby implementacji języka Lisp
* Dostępne techniki 
** Reference counting
** Tracing garbage collectors

== 

Zliczanie referencji to forma automatycznego zarządzania pamięcią w której każdy obiekt ma licznik ilości odniesień do niego. Śmieci są identyfikowane poprzez posiadanie liczby odniesienia równej zero. Licznik odwołań jest zwiększany, gdy odniesienie do obiektu jest tworzone i zmniejszany, gdy odwołanie jest usuwane. Pamięć zajmowana przez obiekt jest zwalniana, gdy liczba osiągnie zero.
== 

* Pamięć jest zwalniana natychmiast gdy wartość licznika osiągnie zero
* Wymaga dodatkowych technik aby wykryć cykle odwołań
* W środowisku wieloprocesorowym dostęp do licznika referencji musi być synchronizowany (atomic)

== 

* Tracing garbage collector najpierw określa które obiekty są dostępne (osiągalne), a następnie usuwa te które są nieosiągalne

== 

* Podstawowym mechanizmem w algorytmach GC typu „tracing” jest tzw. „reachability analisys”
* Umożliwia ona określenie czy dany obiekt jest osiągalny (czasami określany jako „live object”)
* Obiekt jest osiągalny/”żywy” gdy jest co najmniej jedno odwołanie do tego obiektu, z innego obiektu który jest osiągalny, bezpośrednio lub też poprzez innego obiekty, które są osiągalne (transistive closure)

== 

* Analiza „reachability of objects” rozpoczyna się od tzw. „garbage collection roots”,
** Obiekty znajdując się na stosie wątku, „żywego wątku”
** Klasy załadowane przez systemowy „class loader”
** Zmienne lokalne i globalne JNI (Java Native Interface)
** Obiekty wykorzystywane jako monitory podczas synchronizacji

== 

It has been empirically observed that in many programs, the most recently created objects are also those most likely to become unreachable quickly (known as infant mortality or the generational hypothesis)- Wikipedia
== 

* Pokoleniowy odśmiecanie pamięci bazuje na dwóch założeniach,
** Większość nowych obiektów szybko staje się nieosiągalnych
** Ilość odwołań z starych obiektów do nowych obiektów jest niewielka

== 

* Oracle JVM
** Serial
** Parallel
** Concurrent mark sweep
* G1 - Garbage First
* Oracle JRockit Real Time 
* IBM Websphere Real Time
* Azul Zing (pauseless)

== 


== 

* W przypadku pokoleniowego („generational” GC) , alokacja nowych obiektów odbywa się tylko w przestrzeni „Eden”
* Dostępne techniki to:
** „bump-the-pointer”
** TLAB (Thread Local Allocation Buffer)

== 

* Od Java 5 domyślny “garbage collector”
* Wykorzystuje wiele wątków do odśmiecania pamięci
* Domyślnie wiele wątków jest wykorzystywanych tylko podczas “minor collections”, “major collections” wykonywane są przez pojedynczy wątek
* -XX:+UseParallelOldGC umożliwia wykorzystanie wielu wątków także dla „major collections” 

== 

* „minor collections”Odśmiecanie pamięci w generacji „Young”
* „major collections” aka „Full GC”Odśmiecanie pamięci w generacji „Tenured”

== 

* Jednak nie dajmy się zwieźć pozorom, -XX:+UseParallelGC i -XX:+UseParallelOldGC to dwie odmienne implementacje, ParallelOldGC ma do czynienia z o wiele większą przestrzenią generacji “Old”
* Domyślnie na maszynach z N procesorów, wykorzystywanych jest N wątków
* Jednak ilość wątków może być kontrolowana przez parametr -XX:ParallelGCThread=N

== 

* “GC roots” zostają rozdzielone między dostępne wątki, dzięki temu faza “mark” jest krótsza
* Każdy “żywy” obiekt jest natychmiast kopiowany do przestrzeni “To”, lub do przestrzeni “Old”, 
* ** jeśli przetrwał odpowiednią ilość kolekcji,
** lub gdy w „To” nie ma już miejsca dla obiektu

== 

* Przestrzeń “To” staje się przestrzenią “From” i “From”->”To”
* Czyli po każdym przebiegu tego odśmiecacza przestrzeń „To” jest pusta
* Ponieważ „mark and copy” odbywa się wielowątkowo, każdy z wątków GC dostaje swój wycinek “To”
* Bo przecież alokacja nowych obiektów, odbywa się tylko w przestrzeni “Eden”, więc nie będzie nam przeszkadzała lekko defragmentowana przestrzeń “To”

== 


== 

* -XX:+PrintTenuringDistribution
* -XX:NewRatio=2
* -XX:SurvivorRatio=10
* -XX:TargetSurvivorRatio=90
* -XX:MaxTenuringThreshold=30

== 

* O wiele bardziej złożony algorytm, gdyż przestrzeń “Old” jest znacząco większa od przestrzeni „Young” a obiekty, które się tam znajdują wykazują się większym czasem życia
* ParallelOldGC odbywa się w trzech krokach:
* ** parallel marking
** summary step
** sweeping step

== 

* Przestrzeń “Old” zostaje podzielona na regiony
* “GC roots” podzielone pomiędzy w wątki GC
* Za każdym razem gdy obiekt zostanie oznaczony jako “live” (“reacheable”), region w którym się znajdował, zostaje zaktualizowany o ilość “żywych bajtów”
* Dzięki temu na koniec tej fazy wiadome jest ile w danym regionie znajduje się „żywych” danych

== 

* Dla każdego regionu, jest wyznacza wartość “density” (stosunek ilość żywych bajtów do całkowitej ilości bajtów) 
* W tym kroku wiemy także, że podczas poprzedniej kolekcji:
* ** obiekty były kompaktowane do lewej
** nowe obiekty które od tego czasu zostały przeniesione do “Old” znajdują się po prawej stronie
** Więc im obiekt bardziej na lewo tym starszy, tym mniejsza szansa, że będzie usuwany z pamięci

== 

* Powyższe informacje pozwalają na pewna optymalizacje:
* ** zaczynając od lewej, szukany jest region o gęstości (“density”), z którego najwięcej zyskamy jeśli go posprzątamy,
** wszystkie region na lewo nie sprzątane, i nazywane są “dense prefix”
* Dodatkowo podczas tej fazy już wiadomo obiekty z którego regiony zostaną przeniesione do danego regionu (z reguły te na prawo wypełniają te na lewo)

== 

* Regiony które mogą być sprzątane jednocześnie są dzielone miedzy watki,
* ** region które nie zapełniają innych regionów (patrz poprzedni krok)
** lub region które są puste,
* Wątki najpierw usuwają „unreachable objects”
* A potem przesuwają obiekty (compact)
* Dzięki optymalizacji (nie skanujemy całego regionu „Old”), możemy odzyskać dużo pamięci, mniejszym kosztem, ponieważ na lewo są stare obiekty 

== 

* A potem przesuwają obiekty (compact)
* Dzięki optymalizacji (nie skanujemy całego regionu „Old”), możemy odzyskać dużo pamięci, mniejszym kosztem, ponieważ na lewo są stare obiekty

== 

* A co z tymi obiektami, które znajdują się regionie „Old” i posiadają referencji do obiektów w generacji „Young”?
* Zastosowany jest mechanizmy znane jako "card table" i write barrier

== 

* Poprzednie kolektory, są szybkie, jednak muszą zatrzymać działanie aplikacji
* Kosztem mniejszej wydajności CMS
* Cztery kroki
* ** initial mark
** concurrent mark
** remarking
** concurrent sweep

== 

* Zatrzymuje watki aplikacji na krótka chwile, by w wykorzystujac jeden watek, zaznaczyc tylko obiekty które sa bezposrednio dostepne z “GC roots”

== 

* Podczas gdy aplikacja działa dalej, osobny wątek GC kontynuuje zaznaczanie obiektów,

== 

* Ponieważ sytuacja w między czasie może się zmienić CMS, znowu na chwile zatrzymuje aplikacje, by sprawdzić te obiekty które się z międzyczasie zmieniły

== 

* Następuje sprzątanie, w wielu watkach, bez kompaktowania
* Dlatego też alokacja pamięci odbywa się na trochę innych zasadach

== 

174.445: [GC 174.446: [ParNew: 66408K->66408K(66416K), 0.0000618 secs]174.446: [CMS (concurrent mode failure): 161928K->162118K(175104K), 4.0975124 secs] 228336K->162118K(241520K) 
== 

* W przypadku pojawienia się tego komunikatu, CMS zostaje na czas tego uruchomienia „Full GC” zastąpione SerialGC
* Concurrent Mode Failure jest wynikiem defragmentacji generacji „Old” i niemożliwością zaalokowania odpowiedniego ciągłego obszaru pamięci. 

== 


== 

* Analiza dostępności obiektów - „reachability analisys”
* Kopiowanie obiektów pomiędzy przestrzeniami compacting vs non-compacting vs copying
* Aktualizacja referencji do obiektów które zostały przeniesione
* Kompaktowanie pamięci

== 

* G1 znany także jako „garbage first”, to nowy algorytm, który w wersji eksperymentalnej pojawił się już w Java 6, w pełni wspierany od wersji 7u4
* -XX:+UseG1GC
* Jest kolejna próba zminimalizowania pauz w działaniu aplikacji, przy jednoczesnym kompaktowaniu pamięci (przestrzeni „Old”)

== 

* Podobnie jak w przypadku poprzednich modeli pamięć jest podzielona na obszary, w których przechowywane są obiekty w rożnym wieku
* W przeciwieństwie jednak do poprzedników, tych obszarów tworzonych przez G1 mamy do dyspozycji około 2000, każdy z tych obszarów ma taki sam rozmiar, -XX:G1HeapRegionSize=n

== 


== 

* Implementacja G1 utrzymuje listę regionów, które są wolne, i miarę zapotrzebowania przypisuje te regiony do generacji „Young” (Eden/Survivor) lub „Tenured” („Old”)
* W tej implementacji przestrzenie nie są ciągłym obszarem pamięci
* Dzięki temu rozmiar Eden/Survivor/Old może być dostosowywany do zapotrzebowania aplikacji
* Podobnie jak w poprzednich implementacjach, obiekty są promowane( ewakuowane w słowniku GC) do obszarów, które zawierają coraz starsze obiekty

== 

* Alokacja podobnie jak w poprzednich algorytmach, odbywa się głównie w przestrzeni „Eden”, 
* Chyba, że obiekt jest większy niż połowa rozmiary regiony, wtedy takie obiekty są alokowane w specjalnych przestrzeniach zwanych „humongous”
* Kiedy pojemność „Eden” zostanie osiągnięta, rozpoczyna się faza „young garbage collection”, nazywana także „evacuation pause”
* Jest to faza „stop-the-world”, podczas której wykorzystwane jest wiele wątków, i obiekty kopiowane są do „to-space”, lub też w zależności od wieku obiektu (tenured threshold) do przestrzeni „old”

== 

* "Serial" to odśmiecacz typu „stop-the-world”, kopiujący kolekcjoner który wykorzystuje tylko jeden wątek
* "ParNew" to odśmiecacz typu „stop-the-world”, kopiujący kolekcjoner, który wykorzystuje wiele wątków. Różni się od "Parallel Scavenge" pewnymi usprawnieniami które umożliwiają wykorzystanie go w parze z CMS

== 

* "Parallel Scavenge" to odśmiecacz typu „stop-the-world”, kopujący algorytm który wykorzystuje wiele wątków
* "Serial Old" to odśmiecacz typu „stop-the-world”, „mark-sweep-compact” który wykorzystuje pojedynczy wątek
* "ConcurrentMarkSweep" (CMS) to prawie „współbieżny” odśmiecacz, zapewniający krótkie pauzy .
* "Parallel Old" to implementcja ParallelGC na potrzeby generacji „Old”

== 

* UseSerialGC to "Serial" + "Serial Old"
* UseParNewGC to "ParNew" + "Serial Old"
* UseConcMarkSweepGC to"ParNew" + "CMS" + "Serial Old". "CMS" jest wykorzystywany przez większość czasu podczas kolekcji generacji „tenured”. "Serial Old" jest wykorzystywany w sytuacjach wystąpienia „concurrent mode failure„.
* UseParallelGC to "Parallel Scavenge" + "Serial Old"
* UseParallelOldGC to "Parallel Scavenge" + "Parallel Old" 

== 

* PermGen to wydzielony obszar z generacji „tenured” w którym JVM przechowuje:
** „bytecode” metod czyli „method area”
** „constant pool”
** „interned strings” (jest to nieprawdą dla JDK7)
** struktury wewnętrznie wykorzystywane przez JVM
* Generacja „permament” (PermGen) jest odśmiecana za każdym razem gdy odśmiecana jest generacja „tenured”

== 

* Jeśli twoja aplikacja lub biblioteka intensywnie używa,
** java.lang.reflect.Proxy
** net.sf.cglib.Enhancer
** javassist.util.proxy.ProxyFactory
** Apache commons proxy
** AspectJ z „runtime weaving” (SpringFramework się też liczy)
* To wiedz, że PermGen wypełni się szybko
* Dlaczego?

== 

* Poniższe metryki opisują efektywność odśmiecania pamięci
** Przepustowość (throughput)Procent czasu nie spędzanego przez aplikacje na odśmiecaniu, 100% oznacza brak odśmiecania, przyjęło się przyjmować 95-98% jak poprawną wartość
** Narzut na odśmiecanie (GC overhead)odwrotność przepustowości, czyli procent czasu spędzanego przez aplikację na odśmiecanie

== 

** Czas pauzy (pause time)Czas podczas którego działanie aplikacji jest wstrzymane na potrzeby odśmiecania
** Częstotliwość odśmiecania(frequency of collection)jak często w czasie życia aplikacji następuje odśmiecanie

== 

** Narzut pamięci (footprint)Rozmiar pamięci wykorzystywanej przez maszynę JVM
** Promptnessczas pomiędzy momentem kiedy obiekt stał się „unreachable” a momentem kiedy pamięć przez niego zajmowana została zwolniona

== 

* Proste jednak kompletnie niepraktyczne narzędzie to:jmap -heap <vmid>

* Jest to jednak najszybszy sposób żeby sprawdzić z jakimi parametrami odśmiecania aktualnie działa uruchomiona maszyna wirtualna

== 


== 

* Poprzez parametry przekazywane do maszyny wirtualnej
* -XX:+PrintGC
** Major or minor collection
** Rozmiar sterty (generacji) przed odśmiecaniem
** Rozmiar sterty (generacji) po odśmiecaniu
** Całkowity rozmiar sterty (generacji)
** Czas odśmiecania

== 


== 

* -XX:+PrintGCDetails i -XX:+PrintGCTimeStamps
** Bardziej szczegółowe informacje, szczególnie dla algorytmu ConcurrentMarkSweep, gdzie wypisywane są czasy i rozmiar pamięci dla poszczególnych faz

== 


== 

* -XX:+PrintTenuringDistribution
** wyświetla informacje o rozmiarach poszczególnych kategorii wiekowych, ilości odśmiecań, które obiekty przetrwały zanim zostały wypromowane do generacji „Tenured”

== 


== 

* -Xloggc:<filename>zapisuje logi z odśmiecania w wskazanym pliku
* -XX:+UseGCLogFileRotationwłącza rotację plików z logami GC
* -XX:NumberOfGClogFiles=1maksymalna ilość plików z logami GC
* -XX:GCLogFileSize=8Kmaksymalny rozmiar pliku z logami

== 

* Kolejnym narzędziem dostępnym z linii poleceń jest jstat, rozpowszechniany razem z Java SDKjstat -option [-t] [-hlines] vmid [interval [count]]
* Gdzie vmid, jest identyfikatorem procesu JVM,
* jstat umożliwia podpięcie się do procesu JVM i zbieranie różnego typu statystyk, 

== 

* -option to typ statystki którą ma wyświetlać jstat
** class
** compiler
** gc
** gccapacity
** gccause
** gcnew
** gcnewcapacity
** gcoldoldcapacity
** gcpermcapacity
** gcutil

== 

* Warto zapoznać się z powyższymi narzędziami jak i formatami w jakich udostępniane są statystki odśmiecania, jednak na co dzień warto korzystać z wizualnych 
* VisualVM
** Wtyczka VisualGC, wymaga dodatkowej instalacji, pokazuje bieżące zachowanie GC
* GCviewer
** 
		link:https://github.com/chewiebug/GCViewer[https://github.com/chewiebug/GCViewer]
	, szwajcarski scyzoryk w temacie GC
* Jhiccup
** 
		link:http://www.azulsystems.com/jHiccup[http://www.azulsystems.com/jHiccup]
	, czyli mamy czkawkę, czy nie?

== 

* Spośród wielu metryk opisujących zachowanie GC, musisz wybrać jedną, pod którą będziesz starał się zoptymalizować parametry odśmiecania
* Najczęściej będą to:
** Rozmiar sterty
** Przepustowość
** Czas pauzy

== 

* Przedwczesna optymalizacja GCnie rób tego jeśli naprawdę nie musisz
* Brak wiary w ergonomię GCbyć może -XX:MaxGCPauseMillis=<nnn> i -XX:GCTimeRatio=<nnn> to jedyne parametry które powinieneś znać
* Wiara że optymalizacja GC przykryje złe nawyki w pisaniu kodu czy też brak pragmatyzmu w architekturze systemu

== 

* Brak systemowego/całościowego podejścia do testowania wydajności
* stackoverflow.com i google.com to nie są miejsca gdzie znajdziesz parametry swojego JVM
* Brak zrozumienia jak działają poszczególne algorytmy odśmiecania i interakcji pomiędzy JVM i systemem operacyjnym

== 

* Spośród wielu metryk opisujących zachowanie GC, musisz wybrać jedną, pod którą będziesz starał się zoptymalizować parametry odśmiecania
* Najczęściej będą to:
** Rozmiar sterty
** Przepustowość
** Czas pauzy

== 

* Różne wymagania alokacji i odśmiecanie dla różnych architektur
** Przetwarzanie wsadowe
** Aplikacje stanowe i bezstanowe

   
