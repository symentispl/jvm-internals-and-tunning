= Byte code i maszyna wirtualna
:backend: revealjs
:highlighter: pygments
:stem: asciimath
:source-highlighter: pygments
:pygments-css: style
:revealjs_theme: serif
:revealjs_history: true

== Byte code i maszyna wirtualna

  Java Virtual Machine bytecode is a low level language for non existing CPU

=== Struktura pliku .class

----
ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
----

=== Struktura pliku .class

Bytecode is stored in files, which format is defined by
link:http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html[lass
  file format spec]

Bytecode is a stream of single byte size opcodes followed by
defined set operands

=== Hello world

[source, asm]
----
0: getstatic #16
3: ldc #22
5: invokevirtual #24
8: return
----

=== Constant pool

----
#1 = Utf8               ClassWithDefaultConstructor
#2 = Class              #1             // ClassWithDefaultConstructor
#3 = Utf8               java/lang/Object
#4 = Class              #3             // java/lang/Object
#5 = Utf8               <init>
#6 = Utf8               (Ljava/lang/Integer;)V
#7 = Utf8               ()V
#8 = NameAndType        #5:#7          // "<init>":()V
#9 = Methodref          #4.#8          // java/lang/Object."<init>":()V
#10 = Utf8               java/lang/Integer
#11 = Class              #10            // java/lang/Integer
#12 = Utf8               toString
#13 = Utf8               ()Ljava/lang/String;
#14 = NameAndType        #12:#13        // toString:()Ljava/lang/String;
----

=== Interpretacja bytecode

[shaape]
----
                          +-----------------+
                          |                 |
+---------+           +---+-------------+   |
|         |   bci     |                 |   |
| Thread  |---------->| Method bytecode +---+
|         |           |                 |
|         |           +-----------------+
|         |
|         |           +-----------------+
|         |           |                 |
|         |           |  Frame stack    |
|         |           |                 |
|         |           +-----------------+
|         |
|         |           +-----------------+
|         |           |                 |
|         |           | Local variables |
|         |           |                 |
+---------+           +-----------------+
----

=== Bytecode, stack, variables

=== Podstawowe operacje: manipulacja stosem

* `ALOAD`,`ILOAD`,`DLOAD`,`FLOAD`, umieszcza wybraną zmienną lokalną na stosie,
* `DSTORE`,`ASTORE`,`ISTORE`,`FSTORE`, umieszcza wartość z stosu w tablicy zmiennych lokalnych
* każdy z powyższysz opcode przyjmuje dodatkowy bajt jak indeks w tablicy zmiennych lokalnych
* `DUP`
* `POP`

=== invoke*

=== Exception table

=== StackMapTable

=== LocalVariableTable

=== LineNumberTable

=== Przegląd narzędzi do manipulacji

* ASM
* jitescript
* javassist
* bytebuddy
* byteman

=== Java Instrumentation API

=== Interpretacja bytecode

* C++ template
* ASM template
* interpreter frame
* OpenJDK Zero and Shark

== Kompilator Just in Time

Jest częscią maszyny wirtualnej HotSpot i jest odpowiedzialny za optymalizację
i kompilację bytecode w czasie działania maszyny wirtualnej.

Historycznie w Sun/OpenJDK/Oracle JDK były od początku dostępna dwa kompilatory,
client (znany także jako C1) oraz server (znany także jako C2 lub opto).

Od wersji JDK8, domyślnie działają one razem jako tzw. tiered compiler,
kontrolowany przez flagę `-XX:+TieredCompilation`

=== Kompilator C1

Jest to szybki kompilator, operujący na CFG (control flow graph)
SSA (static single assigement form) IR (intermediate representation)

https://en.wikipedia.org/wiki/Static_single_assignment_form

=== Static single assignment

[stem]
++++
x=1
y=2
x_1=y
y_1=2
++++

=== Kompilator C1

Kompilator ten wykorzystuje mechanizm szablonów generujących kod natywny a
także liniową alokację rejestrów.

Kompilator C1 odpowiedzialny jest za takie optymalizacje jak, inlining,
constant propagation, value range propagation,
sparse conditional constant propagation, dead code elimination,
global value numbering, partial redundancy elimination, strength reduction,
register allocation.

=== Inlining: matka wszystkich optymalizacji

[source,java]
----
int doubleAndAdd(int x, int y){
  return doubleInt(x)+doubleInt(y);
}

int doubleInt(int i){
  return i+i;
}
----

[source,java]
----
int doubleAndAdd(int x, int y){
  return (x+x)+(y+y);
}
----

=== Ekonomia inlining

* nie ma potrzeby tworzenia nowej ramki na stosie (stack frame)
* zbędne staje się odwołanie do tablicy metod wirtualnych (vtable)
* metody które poddają się tej optymalizacji
** `private`
** `final`
** `static`
** pozostałe, w określonych warunkach (ale o tym poźniej)

=== Optymalizacja inlining

* `-XX:FreqInlineSize=325`, maksymalny rozmiar metody (w bytecode), inline przez
C2
* `-XX:InlineSmallCode=2000`
* `-XX:MaxInlineLevel=9`
* `-XX:MaxInlineSize=35`
* `-XX:MaxRecursiveInlizeLevel=1`
* `-XX:MinInliningThreshold=250`

=== Here comes the megamorph

=== inline cache

=== Logowanie optymalizacji

`-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompilation -XX:+PrintInlining`

gdy chcesz zapisać wynik kompilacji do pliku
`-XX:+LogCompilation -XX:LogFile=compilation.log`


=== Logowanie optymalizacji
----
15684 3907       4       org.objectweb.asm.ClassReader::<init> (10 bytes)
                !              @ 3   org.objectweb.asm.ClassReader::a (163 bytes)   already compiled into a big method
                               @ 6   org.objectweb.asm.ClassReader::<init> (9 bytes)   inline (hot)
                                 @ 5   org.objectweb.asm.ClassReader::<init> (257 bytes)   inline (hot)
                                   @ 1   java.lang.Object::<init> (1 bytes)   inline (hot)
                                   @ 14   org.objectweb.asm.ClassReader::readShort (27 bytes)   inline (hot)
                                   @ 36   org.objectweb.asm.ClassReader::readUnsignedShort (26 bytes)   inline (hot)
                                   @ 202   org.objectweb.asm.ClassReader::readUnsignedShort (26 bytes)   inline (hot)
                               @ 10   java.util.zip.ZipEntry::isDirectory (10 bytes)   inline (hot)
                                 @ 6   java.lang.String::endsWith (17 bytes)   inline (hot)
                                   @ 13   java.lang.String::startsWith (72 bytes)   inline (hot)
                               @ 18   java.util.zip.ZipEntry::getName (5 bytes)   accessor
                               @ 26   org.eclipse.jetty.annotations.AnnotationParser::isValidClassFileName (145 bytes)   inline (hot)
----

=== Czytanie logów kompilatora

* compilation id
* symbol
* compiler tier [1..4], gdzie 1-3 to C1 a 4 to C2
* method
* compiler cause

=== Symbole

|===
| Symbol | Meaning

| % | On stack replacement

| s | Synchronized method

| ! | Method has exception handlers

| b | Blocking compilation

| n | Native wrapper

| m | Nie pamiętam spawdzić

|===

=== Dead code elimination

=== Global value numbering

Jest to optymalizacja która pomaga wyeliminować zbędny kod. Odbywa się to
poprzez przypisanie tej samej wartości do zmiennych i wyrażeń, które są tożsame.

[source,java]
----
w := 3      # -> 1
x := 3      # -> 1
y := x + 4  # -> 2
z := w + 4  # -> 2
----

Po zastąpieniu wyrażen które zostały przypisane do tych samych wartości:

[source, java]
----
w := 3
x := w
y := w + 4
z := y
----

=== Loop unrolling

=== Kompilator C2

=== sea of nodes

=== register allocation by graph coloring

=== On Stack Replacement

=== Traps, Type profile and Megamorphs

=== Lock elision, biased locking, adaptive locking (fast path lock)

=== Escape analisys (ojciec optymalizacji)

=== Deopitmization

=== Code cache

== Narzędzia

=== Disasembly plugin

=== JITWatch

=== JMH
