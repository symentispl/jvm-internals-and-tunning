== bytecode

== !

Java bytecode is an assembly language for a non existing CPU

=== a JVM CPU

stack +
local variables +
method area (+ bci(**b**yte **c**ode **i**ndex))

[role="highlight_title"]
=== stack

image::17042623299_eb189a7209_b-752x490.jpg[background]

[role="highlight_title"]
=== local variables

image::blauwbord.jpg[background]

[role="highlight_title"]
=== method area (+ bci)

image::libraries.jpg[background]

=== WARNING!

this is only true for interpreter frame

(we are going to explain this in next chapters)

=== !

[source,java]
----
public class HelloWorld{
  public static void main(String[] argv){
    System.out.println("Hello world!");
  }
}
----

=== javap (disassembler)

a tool bundled with JDK, bytecode disassembler

  javap -c -v ClassName

== classfile

bytecode is stored in files, +
which format is defined by
link:http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html[class file format spec] +

=== !

classname +
modifiers +
superclass +
classpool +
implemented interfaces +
fields (and attributes) +
methods (and attributes)


=== classpool?

dictionary of all symbols used in a class:

* imported class names
* methods names
* string and other literals
* bootstrap handles

=== attributes?

a place where all  +
**for future use things** go :)

* annotations
* stack map table
* exceptions table
* source line table

will comeback to it!

=== !

bytecode is a stream of single byte size opcodes followed by number of operands

=== example

[code, nasm]
----
iload       #16
  ^          ^
operand   word size
        22(index in classpool)
----

=== stack manipulation

[source, nasm]
----
astore   # store reference from top of stack to variables
aload    # load reference from variables to top of stack
areturn  # return reference from top of stack to caller
dup      # duplicate top of stack
pop      # discard top of stack
----

=== operand prefixes

* __i__ integer
* __l__ long
* __b__ byte
* __d__ double
* __a__ reference

== invoke*

[source, nasm]
----
invokevirtual     # late binding to a receiver
invokestatic      # static binding, no receiver
invokespecial     # static binding to a receiver
invokeinterface   # late binding, receiver is an interface type
invokedynamic     # oh my god, things are getting weird
----

=== virtual methods table

Java uses "single method dispatch", it means it uses single object (`this`) to
resolve target method.

Because of this it can use **virtual methods table** technique.

=== !

[source, java]
----
class A {
  void method1(){
    out.println("A.method1");
  }
}

class B extends A{
  void method1(){
    out.println("B.method1");
  }

  void method2(){
    out.println("B.method1");
  }
}
----

=== *class A vtable*

[%autowidth,frames=sides,grid=columns]
|===
|index | target method

| 0 | `out.println("A.method1");`

|===

=== *class B vtable*

[%autowidth,frames=sides,grid=columns]
|===
|index | target method

| 0 | `out.println("B.method1");`
| 1 | `out.println("B.method2");`

|===

=== invokeinterface

[source, java]
----
interface Intrf {
  void method1();
}

class A implements Intrf{
  void method1(){
    System.out.println("A.method1");
  }
}

class B  implements Intrf{

  void method2(){
    System.out.println("B.method1");
  }

  void method1(){
    System.out.println("B.method1");
  }
}
----

=== *class A vtable*

[%autowidth,frames=sides,grid=columns]
|===
|index | target method

| 0 | `out.println("A.method1");`

|===

=== *class B vtable*

[%autowidth,frames=sides,grid=columns]
|===
|index | target method

| 0 | `out.println("B.method2");`
| 1 | `out.println("B.method1");`

|===

=== invokespecial

because private methods and constructors calls are "statically bound" +
(target method known at compile) +
we don't need to lookup vtable at call site +

=== !

yes, `invokevirtual` and `invokeinterface` are "late bound"

=== gif me moar!!!

http://www.cs.ucsb.edu/~urs/oocsb/papers/TRCS99-24.pdf[Software and Hardware Techniques for Efficient Polymorphic Calls by Karel Driesen]

https://shipilev.net/blog/2015/black-magic-method-dispatch/[The Black Magic of (Java) Method Dispatch by Aleksey Shipil—ëv]

[role="highlight_title"]
=== invokedynamic

image::https://media.giphy.com/media/3ohfFr0PcMTsonsgb6/giphy.gif[background]

=== !

it is like having vtable generated at runtime, +
+ +
you can have multiple dispatch (sort of)

=== control flow

if in doubt +
use `goto`

=== exceptions

take a look at exceptions table

=== other attributes

=== creating new objects

== bytecode interpreter

== classloading

== what's in it for me?

most modern "enterprise" frameworks heavily relay on bytecode manipulation

* Hibernate
* Spring
* JEE containers
* Mockito

[role="highlight_title"]
== javaagent

image::1280x720-Mz9.jpg[background]

=== !

Java agent was introduced in JDK 1.5, it allows you to hook your code into
class loading machinery, in order to modify loaded classes.

=== get you jar ready

----
Premain-Class: pl.symentis.agent.Agent
----

=== !

[source,java]
----
import java.lang.instrument.Instrumentation;

public clas Agent {

  public static void premain(String agentArgs,
                             Instrumentation inst) {
    inst.addTransformer(new CustomCodeTransformer());
  }

}
----

=== !

[source,java]
----
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;

public class CustomCodeTransformer implements ClassFileTransformer{

  public byte[] transform(
    ClassLoader loader,
    String className,
    Class<?> classBeingRedefined,
    ProtectionDomain protectionDomain,
    byte[] classfileBuffer) throws IllegalClassFormatException{}

      // HERE YOU CAN DO FANCY THINGS WITH BYTECODE

      return classfileBuffer;
  }
}
----

=== jvm with agent

----
java -javaagent:agent.jar Main
----

=== !

image::http://i.giphy.com/gVE7nURcnD9bW.gif[background]

[role="highlight_title"]
== tools

image::old-tools.jpg[background]

=== asm

=== bytebuddy

=== byteman

== q&a
